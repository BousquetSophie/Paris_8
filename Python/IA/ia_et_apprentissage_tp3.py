# -*- coding: utf-8 -*-
"""IA_et_apprentissage_TP3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aDQWuKyy-3dViD2Si_GhLmsOsiXLF9-3

Bienvenue dans ce troisième TP d’apprentissage automatique !

La semaine dernière, nous avons utilisé l'apprentissage automatique pour essayer de répondre à la question "Combien d'heures devrais je réviser pour valider mon cours d'IA et apprentissage?".

Nous avions pour ce faire développé un modèle de régression logistique univarié, dont les performances étaient plutôt satisfaisante. Il est en revanche un peu audacieux de penser que seul le temps passé à réviser décide de la note qu'un.e étudiant.e peut obtenir à un examen. En effet, cette grandeur est clairement multifactorielle.

Pour améliorer les performances des modèles que nous avons ajusté jusqu'ici, nous sommes retourné voir les étudiant.e.s qui ont servi à constituer notre jeu de données, et nous leur avons demandé de renseigner le nombre d'heures passées à travailler le cours chaque semaine pendant le semestre. Il semble raisonnable de penser que cette information devrait nous permettre d'affiner nos prédictions.

** Objectif dy TP **

Pour prendre en compte ces nouvelles informations dans nos précédents, nous allons développer plusieurs modèles:

*   Un modèle de régression linéaire multivarié afin de prédire la note qu'un.e étudiant.e peut espérer avoir
*   Un modèle de régression logistique multivarié afin d'estimer la probabilité qu'un.e étudiant.e valide le cours
*   Un modèle de régression logistique multinomiale afin d'estimer la probabilité que l'étudiant.e ne valide pas, valide avec moins de 15, ou avec plus de 15

Commencez par exécutez la case suivante, qui importe toutes les librairies nécessaire à l'execution du TP.
"""

import torch
import sklearn
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt

"""#  1. Chargement et visualisation des données

Maintenant que notre environnement de travail est prêt, nous allons pouvoir charger notre jeu de données et regarder un peu à quoi il ressemble. Uploadez le fichier "train.csv" fourni avec ce notebook dans vos fichiers, et chargez le dans le jupyter avec la fonction pandas pd.read_csv
"""

train_df = pd.read_csv('training_dataset.csv')

"""Affichez une description de votre jeu de données ici en utilisant la méthode .describe() associée à votre dataframe pandas"""

train_df.describe()

"""En utilisant la librairie pyplot, visualisez la distribution des variables prédictives et à expliquer de votre jeu de données, ainsi que leur relation.

Vous pourrez pour ce faire utiliser les fonctions pyplot plt.hist et plt.scatter
"""

plt.hist(train_df.cours)

plt.hist(train_df.revisions)

plt.hist(train_df.note)

plt.scatter(train_df.revisions, train_df.cours, c= train_df.note, cmap='viridis')

"""Décrivez ici qualitativement votre jeu de données.

Un modèle de régression linéaire multivariée semble t'il indiqué ici pour implémenter un algorithme capable de déterminer si un.e étudiant aura validé son partiel à partir de son temps de révision?

Le jeu

# 2. Modèle de régression linéaire multivarié

Maintenant que l'on connait mieux notre jeu de données, il est temps d'implémenter et d'ajuster notre modèle. Dans un premier temps, nous utiliserons de nouveau Pytorch.

# 2.1. Implémentation du modèle

Rappelez vous, afin d'implémenter un modèle en Pytorch, il est nécessaire d'instancier un objet qui hérite de la classe torch.nn.Module. Jusqu'ici, nous avions instancié tous nos modèles à la main. Quand bien même cela nous a permis de comprendre en profondeur le fonctionnement de PyTorch, ca n'est clairement pas l'approche la plus efficace.

En effet, PyTorch dispose déjà d'une implémentation d'une classe permettant d'instancier n'importe quel modèle linéaire, l'objet torch.nn.Linear. Cet objet applique une transformation linéaire paramétrique à ses entrées, de dimensionalité définie lors de l'instanciation de l'objet.

Le constructeur de cet objet requiert de renseigner deux informations:


*   in_features, la dimensionalité de l'entrée de la couche, c'est à dire dans notre cas le nombre de variables à expliquer
*   out_features, la dimensionalité de la sortie de la couche, c'est à dire dans notre cas le nombre de variable que nous cherchons à prédire
"""

model_lin = torch.nn.Linear(2, 1)

"""# 2.2. Ajustement du modèle

Comme d'habitude, nous allons maintenant implémenter la fonction qui nous permettra d'ajuster notre modèle. Nous aurons notamment besoin des deux objets suivant

*   torch.nn.MSE comme fonction objectif (MSE pour Mean Squared Error)
*   torch.optim.SGD comme algorithme de descente de gradient (SGD pour Stochastic Gradient Descent)
"""

def train_model(X, y, model, num_iter=100, learning_rate=0.01):

    # On définit notre fonction perte
    objectif = torch.nn.MSELoss()

    # On définit notre algorithme d'optimisation (SGD: Stochastic Gradient Descent)
    optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)

    for _ in range(num_iter):
        inputs = torch.tensor(X)
        targets = torch.tensor(y)

        # Calculez les prédictions
        outputs = model(inputs)

        # Calculer la fonction objectif à partir des prédictions et des targets
        loss = objectif(outputs, targets)

        # Calcule le gradient
        optimizer.zero_grad()
        loss.backward()

        # Applique une itération de descente de gradient aux paramètres du modèle
        optimizer.step()

    return model

"""Maintenant que la fonction train_model est implémentée, nous pouvons l'appeler sur notre jeu de données et obtenir un modèle ajusté!

Pour évaluer ses performances, il nous suffit simplement par la suite d'obtenir les prédictions du modèle en lui donnant en entrée nos variables explicatives, puis de calculer le taux d'exactitude.

Ajuster et évaluer les performances de votre modèle pour les valeurs suivantes de l'argument learning rate: [1, 0.1, 0.01, 0.001]
"""

# Instanciez un Tensor contenant nos deux variables explicatives
X_lin = torch.tensor([train_df.revisions, train_df.cours], dtype=torch.float32).T

# Instanciez un Tensor contenant notre variable à prédire
y = torch.tensor(train_df.note, dtype=torch.float32)

# Utilisez la fonction train_model pour ajuster votre modèle de régression linéaire sur votre jeux de données
model_lin = train_model(X_lin, y, model_lin, learning_rate=0.01, num_iter=1000)

# Utilisez le modèle obtenu pour calculer ses prédictions
predictions = model_lin(X_lin)

# Calculez l'erreur quadratique du modèle
mse_lin = torch.nn.MSELoss()(predictions, y.unsqueeze(-1)).item()

print("Erreur quadratique = %.3f" % (mse_lin))

"""Encore une fois, l'erreur quadratique est dans l'absolu difficile à interpréter. On pourrait en revanche la comparer avec celle obtenue avec un modèle de régression univarié, ajusté seulement à partir du nombre d'heure passer à réviser (comme nous l'avons fait dans le premier TP).

L'avantage avec l'objet Linear, c'est qu'il nous permet également d'implémenter ce modèle, tout en restant compatible avec notre fonction train_model.

Instanciez un modèle de régression linéaire univarié et comparez ses performances avec celles du modèle précédent.
"""

# Instanciez un modèle de régression linéaire univarié à partir d'un objet Linear

model_unilin = torch.nn.Linear(1,1)

# Instanciez un Tensor contenant une variable explicatives
X_unilin = torch.tensor([train_df.revisions], dtype=torch.float32).T

# Utilisez la fonction train_model pour ajuster votre modèle de régression linéaire sur votre jeux de données
model_unilin = train_model(X_unilin, y, model_unilin, learning_rate=0.01, num_iter=1000)

# Utilisez le modèle obtenu pour calculer ses prédictions
predictions = model_unilin(X_unilin)

# Calculez l'erreur quadratique du modèle
mse_unilin = torch.nn.MSELoss()(predictions, y.unsqueeze(-1)).item()

print("Erreur quadratique du modèle univarié   = %.3f" % (mse_unilin))
print("Erreur quadratique du modèle multivarié = %.3f" % (mse_lin))

"""L'inclusion de la variable "temps passé à travailler le cours chaque semaine" amène t'elle un gain en terme de performances prédictives?

On peut voir que si on prend un modèle multivarié l'erreur quadratique est plus basse qui si on prend un modèle univarié.

Bonjour ♥
"""
