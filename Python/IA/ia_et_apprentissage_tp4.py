# -*- coding: utf-8 -*-
"""IA_et_apprentissage_TP4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dfQ_tfxvH2cDmyyGIOCAp09FOUxirLx1

Bienvenu dans ce quatrième TP d'apprentissage automatique!

Maintenant que nous commençons à être bien à l'aise avec les méthodes de régression et de classification, (qu'elles soient linéaire, polynomiales ou autre), nous allons délaisser notre jeu de données d'étudiants et de partiels pour découvrir le joyeux monde de la reconnaissance d'images!

Dans ce TP, (et les deux qui suivront), nous nous intéresserons à l'application de méthodes d'apprentissage automatique pour reconnaître dans des images des chiffres écrits à la main. Plus précisément, notre jeu de donnée est constitué de photographies (à une résolution relativement faible) sur lesquelles un unique chiffre est écrit. Notre tâche est de créer une fonction qui prend en entrée cette image, et qui retourne en sortie un entier, correspondant à l'entier affiché sur l'image.

Pour résumer, nos variables sont les suivantes:


*   Variables explicatives: Ensemble des pixels d'une image. En l'occurence pour le jeu de données de ce TP, 8x8 pixels en nuance de gris, chacun correspondant à une variable quantitative (donc 64 variables au total
*   Variable à expliquer/prédire: Chiffre présent sur l'image, qui correspond donc à une variable catégorielle à 10 états (autant que de chiffres en base 10)


Cette tâche a longtemps été un benchmark classique en apprentissage, et quand bien même elle est maintenant considérée comme bien trop simple pour évaluer des modèles modernes, elle reste très pratique (et très usitée) pour l'enseignement.

Cependant, avant de commencer à nous amuser avec ce jeu de données, nous allons une nouvelle fois passer un peu de temps à se familiariser avec le calcul vectoriel et les manipulations de tableau avec numpy. Courage! Tout va bien se passer.

Commencez par executer la case suivante, qui import toutes les librairies nécessaires à l'exécution du TP.
"""

import numpy as np
import time
from sklearn import datasets
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import PolynomialFeatures
np.random.seed(0)

"""# 1. Calcul vectoriel et manipulation de tableau avec numpy

Pour commencer, voici deux array numpy générés aléatoirement qui nous servirons à effectuer différentes manipulations.
"""

W = np.random.uniform(0, 1, size=[3, 5])

"""Affichez la shape de ces deux tableaux en utilisant l'attribut .shape"""

W.shape

"""Affichez la valeur moyenne de chaque ligne du tableau W, d'abord en utilisant des boucles for, puis en utilisant seulement la fonction np.mean.

N'hésitez pas à consulter sa documentation pour comprendre comment l'utiliser.

NB: La fonction np.mean peut aussi implémentée comme méthode d'un objet array.
"""

## CODEZ ICI L'IMPLEMENTATION AVEC DES BOUCLES FOR ##
arr_for = []
for i in range(3):
    arr_for.append(sum(W[i])/5)
print("Avec For:", arr_for)



## CODEZ ICI L'IMPLEMENTATION AVEC np.mean ##
arr_np = np.mean(W, axis=1)
print("Avec np.mean :", arr_np)


for i,j in zip(arr_for, arr_np):
  print(i-j)

"""Affichez la somme des deux derniers termes de chaque colonne de W, d'abord en utilisant des boucles for, puis en utilisant seulement la fonction np.sum.

N'hésitez pas à consulter sa documentation pour comprendre comment l'utiliser.

NB: La fonction np.mean peut aussi implémentée comme méthode d'un objet array.
"""

## CODEZ ICI L'IMPLEMENTATION AVEC DES BOUCLES FOR ##
for i in range(5):
    print(sum(W[1:,i]))


## CODEZ ICI L'IMPLEMENTATION AVEC np.mean ##
np.sum(W[1:],axis=0 )

"""Implémentez la fonction python_dot, qui prend en entrée deux listes de floats de même longueur, et qui retourne la combinaison linéaire de ces deux listes (c'est à dire la somme du produit élément par élément de chaque liste)"""

def python_dot(a, b):
  assert len(a) == len(b), "Les deux listes doivent avoir la meme taille !!"
  somme = 0
  for i in range(len(a)):
      somme += a[i] * b[i]
  return somme


a = np.random.uniform(0, 1, size=3)
b = np.random.uniform(0, 1, size=3)
print("Liste a : ", a)
print("Liste b : ", b)
print("Combinaison linéaire de a et b : ", python_dot(a,b))

"""Implémentez la fonction numpy_dot, qui prend en entrée deux array numpy de dimension 1 et de même shape, et qui retourne la combinaison linéaire de ces deux arrays. Cette fonction a donc exactement le même comportement que python_dot, mais utilise des manipulations numpy au lieu de python."""

def numpy_dot(a, b):
  return sum(a * b)

print("Combinaison linéaire de a et b : ", numpy_dot(a,b))

"""Comparez le temps d'exécution de mille appels à ces deux fonctions sur les array a et b définis dans la case de code suivantes.

---


"""

a = np.random.uniform(0, 1, size=[100])
b = np.random.uniform(0, 1, size=[100])

time_debut_ndot = time.time()
numpy_dot(a,b)
t1 = (time.time() - time_debut_ndot)
print("Temps d'execution de numpy_dot  : ", t1)


time_debut_pdot = time.time()
python_dot(a,b)
t2 = (time.time() - time_debut_pdot)
print("Temps d'execution de python_dot  : ", t2)

print(f"Conclusion : {'python_dot' if t1 > t2 else 'numpy_dot'} est le plus rapide ")

"""Implémentez la fonction python_matmul qui prend en entrée une matrice a (encodées sous forme de liste de listes toutes de même tailles, et un vecteur b tel que len(b) == len(a[0])  qui retourne leur produit matriciel. Rappelez vous, le produit d'une matrice et d'un vecteur correspond à la liste des combinaisons linéaires du vecteur avec chaque ligne de la matrice."""

def python_matmul(a, b):
  s = 0
  for i in range(len(a)):
    for k in range(len(a[0])):
      s += (b[k] * a[i][k])
  return s

a = [[1, 3, 5], [2, 4, 6]]
b = [1, 2, 3]

print(python_matmul(a,b))

"""Implémentez la fonction numpy_matmul, qui prend en entrée une matrice a (encodée comme un array numpy de shape [dim_out, dim_in]) et un vecteur b encodé comme un array numpy également, mais de shape [dim_in, 1] et qui retourne leur produit matriciel, exactement comme la fonction python_matmul"""

def numpy_matmul(a, b):
  return sum(sum(a * b.T))

a = np.array([[1, 3, 5], [2, 4, 6]])
b = np.array([[1], [2], [3]])
print(numpy_matmul(a, b))

"""Comparez le temps d'exécution de mille appels à ces deux fonctions sur les array a et b définis dans la case de code suivantes.

"""

a = np.random.uniform(0, 1, size=[100, 500])
b = np.random.uniform(0, 1, size=[500, 1])


time_debut_nmatmul = time.time()
numpy_matmul(a, b)
t1 = (time.time() - time_debut_nmatmul)
print("Temps d'execution de numpy_matmul  : ", t1)


time_debut_pmatmul = time.time()
python_matmul(a, b)
t2 = (time.time() - time_debut_pmatmul)
print("Temps d'execution de python_matmul  : ", t2)

print(f"Conclusion : {'python_matmul' if t1 > t2 else 'numpy_matmul'} est le plus rapide ")

"""2. Régression polynomiale et reconnaissance de chiffres écrits

Il est maintenant temps de faire notre premier projet de "véritable" apprentissage machine, avec notre projet de reconnaissance de caractères écrits à la main. Exécutez la case suivante, qui télécharge votre jeu de données et en extrait les variables explicatives et à expliquer.
"""

dataset = datasets.load_digits()

X, y = dataset.images, dataset.target

"""En utilisant la librairie pyplot, visualisez la distribution des variables prédictives et à expliquer de votre jeu de données.

Vous pourrez pour ce faire utiliser les fonctions pyplot plt.hist et plt.imshow.
"""

## CODEZ ICI ##

"""Est il facile de visualiser la relation entre les variables explicatives et la variable à expliquer?

(Ecrivez votre réponse dans cette case)

Comme il est impossible (ou très difficile) de savoir a priori quel type de modèle utiliser, nous allons tester plusieurs modèles de régressions logistique polynomiale, de degré 1 à 4. Pour pouvoir les comparer efficacement, il sera donc nécessaire de décomposer le jeu de données en un jeu d'entraînement et un jeu de test.

De plus, les images sont encodées en array de shape [num_images, hauteur, largeur]. Or, les modèles que l'on a vu jusqu'ici ne sont capables que de prendre en entrées des vecteurs, et non des matrices. Il nous sera donc nécessaire de faire un reshape sur les variables d'entrées.
"""

# Modifier la shape de l'array X afin qu'il soit compatible avec l'objet LogisticRegression de sklearn
X = ## CODEZ ICI ##~

# Répartissez aléatoirement les élements du jeu de données (X et y) dans un jeu d'entraînement et un jeu de test
## CODEZ ICI ##
X_train = ## CODEZ ICI ##
y_train = ## CODEZ ICI ##

X_test = ## CODEZ ICI ##
y_test = ## CODEZ ICI ##

"""Utilisez les objets LogisticRegression et PolynomialFeature de sklearn pour implémentez 4 modèles distincts de régression polynomial (un pour chaque degré, de 1 à 4) et comparez les résultats que vous obtenez sur le jeu d'entraînement et le jeu de test."""

## CODEZ ICI ##

"""Que constatez vous?

(Inscrivez votre réponse dans cette case)
"""
